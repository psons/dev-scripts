#!/usr/bin/env python3
import sys
import argparse
import os

def main():
    parser = argparse.ArgumentParser(
        prog='list',
        description='Manipulate string lists that are either delimited values on a single line or newline separated lines'
    )
    
    parser.add_argument('-f', '--file', dest='filename', help='filename to read from')
    parser.add_argument('-d', '--delimiter', dest='delimiter', default=' ', help='delimiter for list items on a single line (default: space)')
    parser.add_argument('--save', dest='save_name', metavar='LIST_NAME', help='save the output to a named fileset in ~/.filesets/')
    parser.add_argument('--load', dest='load_name', metavar='LIST_NAME', help='load a named fileset from ~/.filesets/')
    parser.add_argument('command', choices=['flat', 'tall'], help='flat: convert newlines to delimiter; tall: convert delimiter to newlines')
    parser.add_argument('args', nargs='*', help='list items as command line arguments (when provided, stdin is ignored)')
    
    args = parser.parse_args()
    
    # Determine filesets directory
    filesets_dir = os.path.expanduser('~/.filesets')
    
    # Read input
    if args.args:
        # If command line arguments are provided, use them instead of stdin
        # Join with newlines for processing - they'll be treated as separate list items
        content = '\n'.join(args.args)
    elif args.filename:
        # -f option takes precedence over --load
        try:
            with open(args.filename, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            print(f"Error: File '{args.filename}' not found", file=sys.stderr)
            sys.exit(1)
    elif args.load_name:
        # Load from fileset
        fileset_path = os.path.join(filesets_dir, args.load_name)
        try:
            with open(fileset_path, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            print(f"Error: Fileset '{args.load_name}' not found at {fileset_path}", file=sys.stderr)
            sys.exit(1)
    else:
        # Read from stdin
        content = sys.stdin.read()
    
    # Process based on command
    if args.command == 'flat':
        # Replace newlines with delimiter
        # Strip leading/trailing whitespace and split by lines
        lines = content.strip().split('\n')
        # Filter out empty lines and join with delimiter
        items = [line.strip() for line in lines if line.strip()]
        result = args.delimiter.join(items)
        output = result
    
    elif args.command == 'tall':
        # Replace delimiter with newlines
        # Strip and split by delimiter
        items = content.strip().split(args.delimiter)
        # Filter out empty items and print each on a new line
        items = [item.strip() for item in items if item.strip()]
        output = '\n'.join(items)
    
    # Print output
    print(output)
    
    # Save to fileset if requested
    if args.save_name:
        # Create filesets directory if it doesn't exist
        os.makedirs(filesets_dir, exist_ok=True)
        fileset_path = os.path.join(filesets_dir, args.save_name)
        try:
            with open(fileset_path, 'w') as f:
                f.write(output)
                if not output.endswith('\n'):
                    f.write('\n')
        except Exception as e:
            print(f"Error: Failed to save fileset '{args.save_name}': {e}", file=sys.stderr)
            sys.exit(1)

if __name__ == '__main__':
    main()
